<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Swayn</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
      tailwind.config = {
        theme: {
          extend: {
            colors: {
              'brand-primary': '#0062FF',
              'brand-secondary': '#66A1FF',
            },
            fontFamily: {
              serif: ['Georgia', 'serif'],
            },
          }
        }
      }
    </script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script type="importmap">
{
  "imports": {
    "react": "https://esm.sh/react@18.2.0",
    "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
    "react-dom/": "https://aistudiocdn.com/react-dom@^19.1.1/",
    "react/": "https://aistudiocdn.com/react@^19.1.1/"
  }
}
</script>
  </head>
  <body class="bg-gray-50">
    <div id="root"></div>
    <script src="https://cdn.jsdelivr.net/npm/qrcode@1.5.3/build/qrcode.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lz-string/1.5.0/lz-string.min.js"></script>

    <script type="text/babel" data-presets="react,typescript" data-type="module">
      import React, { useState, useEffect, useRef, useCallback } from 'react';
      import ReactDOM from 'react-dom/client';

      // --- from types.ts ---
      enum AppState {
        SELECTING_FRAME = 'SELECTING_FRAME',
        CAPTURING = 'CAPTURING',
        PREVIEW = 'PREVIEW',
      }

      enum FrameType {
        NORMAL = '일반 프레임',
        SPECIAL = '스페셜 프레임',
      }

      interface FrameConfig {
        id: string;
        cuts: 1 | 2 | 4;
        type: FrameType;
        name: string;
        layout: 'vertical' | 'grid';
        frameClasses: string;
        imageContainerClasses: string;
        imageClasses: string;
      }

      // --- from constants.ts ---
      const FRAME_OPTIONS: FrameConfig[] = [
        {
          id: 'normal-4-grid',
          cuts: 4,
          type: FrameType.NORMAL,
          name: '4컷 그리드 (일반)',
          layout: 'grid',
          frameClasses: 'grid grid-cols-2 gap-2 p-3 bg-white',
          imageContainerClasses: 'aspect-w-3 aspect-h-4',
          imageClasses: 'w-full h-full object-cover rounded-sm',
        },
        {
          id: 'normal-2-vertical',
          cuts: 2,
          type: FrameType.NORMAL,
          name: '2컷 세로 (일반)',
          layout: 'vertical',
          frameClasses: 'flex flex-col gap-2 p-3 bg-white',
          imageContainerClasses: 'aspect-w-4 aspect-h-3',
          imageClasses: 'w-full h-full object-cover rounded-sm',
        },
        {
          id: 'special-4-vertical',
          cuts: 4,
          type: FrameType.SPECIAL,
          name: '4컷 세로 (스페셜)',
          layout: 'vertical',
          frameClasses: 'flex flex-col gap-3 p-4 bg-gradient-to-br from-brand-secondary to-brand-primary',
          imageContainerClasses: 'aspect-w-16 aspect-h-9 border-4 border-white rounded-lg shadow-lg',
          imageClasses: 'w-full h-full object-cover rounded-md',
        },
        {
          id: 'special-1-full',
          cuts: 1,
          type: FrameType.SPECIAL,
          name: '1컷 와이드 (스페셜)',
          layout: 'vertical',
          frameClasses: 'p-4 bg-gray-800',
          imageContainerClasses: 'aspect-w-16 aspect-h-9 border-8 border-brand-secondary rounded-xl shadow-2xl',
          imageClasses: 'w-full h-full object-cover rounded-md',
        },
      ];

      const COUNTDOWN_SECONDS = 3;

      // --- from components/icons ---
      const CameraIcon: React.FC<React.SVGProps<SVGSVGElement>> = (props) => (
        <svg {...props} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" >
          <path d="M14.5 4h-5L7 7H4a2 2 0 0 0-2 2v9a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2V9a2 2 0 0 0-2-2h-3l-2.5-3z" />
          <circle cx="12" cy="13" r="3" />
        </svg>
      );
      const DownloadIcon: React.FC<React.SVGProps<SVGSVGElement>> = (props) => (
        <svg {...props} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" >
          <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4" />
          <polyline points="7 10 12 15 17 10" />
          <line x1="12" y1="15" x2="12" y2="3" />
        </svg>
      );
      const RetryIcon: React.FC<React.SVGProps<SVGSVGElement>> = (props) => (
        <svg {...props} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" >
          <path d="M21 12a9 9 0 0 0-9-9 9.75 9.75 0 0 0-6.74 2.74L3 8" />
          <path d="M3 3v5h5" />
          <path d="M3 12a9 9 0 0 0 9 9 9.75 9.75 0 0 0 6.74-2.74L21 16" />
          <path d="M21 21v-5h-5" />
        </svg>
      );
      const FrameIcon: React.FC<React.SVGProps<SVGSVGElement>> = (props) => (
        <svg {...props} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" >
          <rect x="3" y="3" width="18" height="18" rx="2" ry="2" />
          <line x1="3" y1="9" x2="21" y2="9" />
          <line x1="9" y1="21" x2="9" y2="9" />
        </svg>
      );
      const QrCodeIcon: React.FC<React.SVGProps<SVGSVGElement>> = (props) => (
        <svg {...props} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" >
          <rect x="3" y="3" width="7" height="7" />
          <rect x="14" y="3" width="7" height="7" />
          <rect x="3" y="14" width="7" height="7" />
          <line x1="14" y1="14" x2="14" y2="14.01" />
          <line x1="21" y1="14" x2="21" y2="14.01" />
          <line x1="14" y1="21" x2="14" y2="21.01" />
          <line x1="21" y1="21" x2="21" y2="21.01" />
          <line x1="17.5" y1="17.5" x2="17.5" y2="17.51" />
        </svg>
      );

      // --- from components/QRCode.tsx ---
      const QRCode: React.FC<{ value: string; size?: number; }> = ({ value, size = 256 }) => {
        const canvasRef = useRef<HTMLCanvasElement>(null);

        useEffect(() => {
          if (canvasRef.current && (window as any).QRCode) {
            (window as any).QRCode.toCanvas(
              canvasRef.current,
              value,
              { width: size, margin: 1 },
              (error: any) => {
                if (error) console.error('QRCode generation error:', error);
              }
            );
          }
        }, [value, size]);

        return <canvas ref={canvasRef} style={{ width: `${size}px`, height: `${size}px` }} />;
      };

      // --- from components/Header.tsx ---
      const Header: React.FC = () => {
        return (
          <header className="bg-white shadow-md w-full p-4">
            <div className="container mx-auto flex flex-col items-center justify-center">
              <h1 className="text-5xl font-bold text-brand-primary font-serif tracking-widest">Swayn</h1>
              <p className="text-sm text-brand-secondary font-serif mt-1">Feel / Swear / Sway</p>
            </div>
          </header>
        );
      };

      // --- from components/FrameSelector.tsx ---
      const FramePreview: React.FC<{ frame: FrameConfig }> = ({ frame }) => {
        const cuts = Array.from({ length: frame.cuts });
        return (
          <div className={`${frame.frameClasses} w-full h-full shadow-inner rounded-md bg-opacity-50`}>
            {cuts.map((_, index) => (
              <div key={index} className={`${frame.imageContainerClasses} bg-blue-100 rounded-sm flex items-center justify-center`}>
                  <FrameIcon className="w-6 h-6 text-brand-secondary" />
              </div>
            ))}
          </div>
        );
      };
      
      const FrameSelector: React.FC<{ onFrameSelect: (frame: FrameConfig) => void; }> = ({ onFrameSelect }) => {
        return (
          <div className="bg-white p-8 rounded-xl shadow-lg animate-fade-in">
            <h2 className="text-3xl font-bold text-center mb-2 text-brand-primary">프레임 선택</h2>
            <p className="text-center text-gray-500 mb-8">마음에 드는 프레임을 선택하고 촬영을 시작하세요!</p>
            <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6">
              {FRAME_OPTIONS.map((frame) => (
                <div
                  key={frame.id}
                  className="border-2 border-transparent hover:border-brand-primary p-4 rounded-lg cursor-pointer transition-all duration-300 bg-gray-50 hover:shadow-xl"
                  onClick={() => onFrameSelect(frame)}
                >
                  <div className="h-48 mb-4">
                    <FramePreview frame={frame} />
                  </div>
                  <h3 className="font-semibold text-center text-gray-800">{frame.name}</h3>
                  <p className="text-sm text-center text-gray-500">{frame.type}</p>
                </div>
              ))}
            </div>
          </div>
        );
      };
      
      // --- from components/CameraView.tsx ---
      const CameraView: React.FC<{ frameConfig: FrameConfig; onCaptureComplete: (photos: string[]) => void; }> = ({ frameConfig, onCaptureComplete }) => {
        const [photoCount, setPhotoCount] = useState(0);
        const [countdown, setCountdown] = useState<number | null>(null);
        const [isCapturing, setIsCapturing] = useState(false);
        const [cameraError, setCameraError] = useState<string | null>(null);
        const videoRef = useRef<HTMLVideoElement>(null);
        const canvasRef = useRef<HTMLCanvasElement>(null);
        const photosRef = useRef<string[]>([]);

        const startCamera = useCallback(async () => {
          try {
            const stream = await navigator.mediaDevices.getUserMedia({ video: true });
            if (videoRef.current) {
              videoRef.current.srcObject = stream;
            }
            setCameraError(null);
          } catch (err) {
            console.error("Error accessing camera: ", err);
            if (err instanceof Error && err.name === 'NotFoundError') {
              setCameraError("카메라를 찾을 수 없습니다. 기기에 카메라가 연결되어 있는지 확인해주세요.");
            } else {
              setCameraError("카메라에 접근할 수 없습니다. 브라우저에서 카메라 권한을 허용했는지 확인해주세요.");
            }
          }
        }, []);
        
        const stopCamera = () => {
            if (videoRef.current && videoRef.current.srcObject) {
              const stream = videoRef.current.srcObject as MediaStream;
              stream.getTracks().forEach(track => track.stop());
              videoRef.current.srcObject = null;
            }
        };

        const capturePhoto = useCallback(() => {
          if (videoRef.current && canvasRef.current) {
            const video = videoRef.current;
            const canvas = canvasRef.current;
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
            const context = canvas.getContext('2d');
            if (context) {
              context.drawImage(video, 0, 0, video.videoWidth, video.videoHeight);
              const dataUrl = canvas.toDataURL('image/jpeg');
              photosRef.current.push(dataUrl);
              setPhotoCount(prev => prev + 1);
            }
          }
        }, []);

        const startCaptureProcess = useCallback(() => {
          if (isCapturing || photoCount >= frameConfig.cuts) return;

          setIsCapturing(true);
          let currentCountdown = COUNTDOWN_SECONDS;
          setCountdown(currentCountdown);

          const countdownInterval = setInterval(() => {
            currentCountdown -= 1;
            setCountdown(currentCountdown);
            if (currentCountdown <= 0) {
              clearInterval(countdownInterval);
              setCountdown(null);
              capturePhoto();
              setIsCapturing(false);
            }
          }, 1000);
        }, [isCapturing, photoCount, frameConfig.cuts, capturePhoto]);

        useEffect(() => {
          startCamera();
          return () => {
              stopCamera();
          }
        }, [startCamera]);

        useEffect(() => {
          if (photoCount > 0 && photoCount < frameConfig.cuts) {
            setTimeout(() => startCaptureProcess(), 1000); // Pause before next countdown
          } else if (photoCount === frameConfig.cuts) {
            stopCamera();
            onCaptureComplete(photosRef.current);
          }
        }, [photoCount, frameConfig.cuts, onCaptureComplete, startCaptureProcess]);

        return (
          <div className="w-full flex flex-col items-center">
            <div className="relative w-full max-w-2xl aspect-w-4 aspect-h-3 bg-gray-900 rounded-lg shadow-2xl overflow-hidden">
              <video ref={videoRef} autoPlay playsInline muted className="w-full h-full object-cover transform scale-x-[-1]"></video>
              {cameraError && (
                  <div className="absolute inset-0 flex items-center justify-center bg-black bg-opacity-80 text-white p-4">
                      <p className="text-center font-semibold">{cameraError}</p>
                  </div>
              )}
              {countdown !== null && countdown > 0 && !cameraError && (
                <div className="absolute inset-0 flex items-center justify-center bg-black bg-opacity-50">
                  <div className="text-9xl font-bold text-white animate-ping">{countdown}</div>
                </div>
              )}
              {countdown === 0 && !cameraError && (
                <div className="absolute inset-0 flex items-center justify-center bg-white bg-opacity-70">
                  <div className="text-8xl font-bold text-brand-primary animate-pulse">찰칵!</div>
                </div>
              )}
            </div>
            <canvas ref={canvasRef} className="hidden"></canvas>
            <div className="mt-6 text-center">
               <p className="text-xl text-gray-600 mb-4">{photoCount} / {frameConfig.cuts} 장 촬영됨</p>
              {!isCapturing && photoCount < frameConfig.cuts && (
                 <button 
                   onClick={startCaptureProcess} 
                   disabled={!!cameraError}
                   className="px-8 py-4 bg-brand-primary text-white font-bold rounded-full shadow-lg hover:bg-blue-700 transition-transform transform hover:scale-105 focus:outline-none focus:ring-4 focus:ring-brand-secondary disabled:bg-gray-400 disabled:cursor-not-allowed disabled:transform-none"
                 >
                  {photoCount === 0 ? '촬영 시작' : '다음 사진 찍기'}
                </button>
              )}
            </div>
          </div>
        );
      };

      // --- from components/PhotoPreview.tsx ---
      const PhotoPreview: React.FC<{ frameConfig: FrameConfig; photos: string[]; onRetry: () => void; isSharedView?: boolean; }> = ({ frameConfig, photos, onRetry, isSharedView = false }) => {
        const photoStripRef = useRef<HTMLDivElement>(null);
        const [shareUrl, setShareUrl] = useState<string | null>(null);

        useEffect(() => {
          if (!isSharedView && photos.length > 0 && (window as any).lzString) {
            const photoData = photos.map(p => p.split(',')[1]);
            const joinedData = photoData.join('|');
            const compressed = (window as any).lzString.compressToEncodedURIComponent(joinedData);
            const url = `${window.location.origin}${window.location.pathname}#preview&frame=${frameConfig.id}&photos=${compressed}`;
            setShareUrl(url);
          }
        }, [isSharedView, photos, frameConfig.id]);
        
        const generateCanvasImage = async (): Promise<string | null> => {
            const element = photoStripRef.current;
            if (!element) return null;
            
            const originalShadow = element.style.boxShadow;
            element.style.boxShadow = 'none';

            try {
                const { default: html2canvas } = await import('https://cdn.skypack.dev/html2canvas');
                const canvas = await html2canvas(element, {
                    scale: 2,
                    backgroundColor: null,
                    useCORS: true,
                });
                return canvas.toDataURL('image/png');
            } catch (error) {
                console.error("Failed to generate canvas: ", error);
                return null;
            } finally {
                element.style.boxShadow = originalShadow;
            }
        };

        const downloadImage = async () => {
          const imageDataUrl = await generateCanvasImage();
          if (imageDataUrl) {
            const link = document.createElement('a');
            link.download = `swayn-photobooth-${new Date().getTime()}.png`;
            link.href = imageDataUrl;
            link.click();
          } else {
            alert("사진을 다운로드하는 데 실패했습니다.");
          }
        };

        if (isSharedView) {
          return (
            <div className="w-full flex flex-col items-center animate-fade-in">
              <h2 className="text-3xl font-bold text-center mb-2 text-gray-700">사진을 저장하세요!</h2>
              <p className="text-center text-gray-500 mb-8">아래 버튼을 눌러 기기에 사진을 다운로드하세요.</p>
              
              <div ref={photoStripRef} className={`${frameConfig.frameClasses} rounded-lg shadow-xl w-full max-w-sm`}>
                {photos.map((photo, index) => (
                  <div key={index} className={frameConfig.imageContainerClasses}>
                    <img src={photo} alt={`Captured ${index + 1}`} className={`${frameConfig.imageClasses} transform scale-x-[-1]`} />
                  </div>
                ))}
              </div>

              <div className="mt-8">
                <button onClick={downloadImage} className="flex items-center px-8 py-4 bg-brand-primary text-white font-bold rounded-full shadow-lg hover:bg-blue-700 transition-transform transform hover:scale-105 focus:outline-none focus:ring-4 focus:ring-brand-secondary">
                  <DownloadIcon className="w-6 h-6 mr-3" />
                  다운로드
                </button>
              </div>
            </div>
          );
        }

        return (
          <div className="w-full flex flex-col items-center animate-fade-in">
            <h2 className="text-3xl font-bold text-center mb-2 text-gray-700">완성!</h2>
            <p className="text-center text-gray-500 mb-8">QR 코드를 스캔하여 사진을 저장하세요.</p>
            
            <div className="w-full flex flex-col md:flex-row items-center justify-center gap-8 md:gap-12 p-4">
              <div ref={photoStripRef} className={`${frameConfig.frameClasses} rounded-lg shadow-xl w-full max-w-xs sm:max-w-sm`}>
                {photos.map((photo, index) => (
                  <div key={index} className={frameConfig.imageContainerClasses}>
                    <img src={photo} alt={`Captured ${index + 1}`} className={`${frameConfig.imageClasses} transform scale-x-[-1]`} />
                  </div>
                ))}
              </div>

              <div className="flex flex-col gap-6 w-full md:w-auto max-w-sm">
                  <div className="text-center p-6 bg-white/70 rounded-2xl shadow-md flex flex-col items-center">
                      <h3 className="text-xl font-semibold text-gray-800 mb-2">모바일로 저장</h3>
                      <p className="text-gray-600 mb-4 text-sm">스마트폰으로 스캔하세요.</p>
                      {shareUrl ? (
                          <div className="p-3 bg-white rounded-lg inline-block ring-4 ring-brand-secondary/50">
                              <QRCode value={shareUrl} size={180} />
                          </div>
                      ) : (
                          <div className="w-[204px] h-[204px] bg-gray-100 flex items-center justify-center rounded-lg text-gray-500">
                              <p>QR 코드 생성중...</p>
                          </div>
                      )}
                  </div>
              </div>
            </div>

            <div className="mt-10 flex justify-center gap-4">
              <button onClick={onRetry} className="flex items-center px-8 py-3 bg-gray-200 text-gray-800 font-semibold rounded-full shadow-md hover:bg-gray-300 transition-transform transform hover:scale-105 focus:outline-none focus:ring-4 focus:ring-gray-300">
                <RetryIcon className="w-5 h-5 mr-2" />
                다시 찍기
              </button>
              <button onClick={downloadImage} className="flex items-center px-8 py-3 bg-brand-primary text-white font-bold rounded-full shadow-lg hover:bg-blue-700 transition-transform transform hover:scale-105 focus:outline-none focus:ring-4 focus:ring-brand-secondary">
                <DownloadIcon className="w-5 h-5 mr-2" />
                다운로드
              </button>
            </div>
          </div>
        );
      };

      // --- from App.tsx ---
      const App: React.FC = () => {
        const [appState, setAppState] = useState<AppState>(AppState.SELECTING_FRAME);
        const [selectedFrame, setSelectedFrame] = useState<FrameConfig>(FRAME_OPTIONS[0]);
        const [capturedPhotos, setCapturedPhotos] = useState<string[]>([]);
        const [isInitialized, setIsInitialized] = useState(false);
        const [isSharedView, setIsSharedView] = useState(false);

        useEffect(() => {
          try {
            const hash = window.location.hash;
            if (hash.startsWith('#preview&frame=')) {
              const params = new URLSearchParams(hash.substring(hash.indexOf('&') + 1));
              const frameId = params.get('frame');
              const compressedPhotos = params.get('photos');

              if (frameId && compressedPhotos && (window as any).lzString) {
                const frame = FRAME_OPTIONS.find(f => f.id === frameId);
                const decompressed = (window as any).lzString.decompressFromEncodedURIComponent(compressedPhotos);
                const photos = decompressed.split('|').map((data: string) => `data:image/jpeg;base64,${data}`);
                
                if (frame && photos.length > 0) {
                  setSelectedFrame(frame);
                  setCapturedPhotos(photos);
                  setAppState(AppState.PREVIEW);
                  setIsSharedView(true);
                  window.history.replaceState(null, document.title, window.location.pathname + window.location.search);
                }
              }
            }
          } catch (error) {
            console.error("Failed to parse share URL", error);
            window.history.replaceState(null, document.title, window.location.pathname + window.location.search);
          } finally {
              setIsInitialized(true);
          }
        }, []);

        const handleFrameSelect = (frame: FrameConfig) => {
          setSelectedFrame(frame);
          setAppState(AppState.CAPTURING);
        };

        const handleCaptureComplete = (photos: string[]) => {
          setCapturedPhotos(photos);
          setAppState(AppState.PREVIEW);
        };

        const handleRetry = () => {
          setCapturedPhotos([]);
          setAppState(AppState.SELECTING_FRAME);
          setIsSharedView(false);
        };
        
        const renderContent = () => {
          if (!isInitialized) {
              return <div className="text-center text-brand-primary">Loading...</div>;
          }
          switch (appState) {
            case AppState.SELECTING_FRAME:
              return <FrameSelector onFrameSelect={handleFrameSelect} />;
            case AppState.CAPTURING:
              return <CameraView frameConfig={selectedFrame} onCaptureComplete={handleCaptureComplete} />;
            case AppState.PREVIEW:
              return <PhotoPreview frameConfig={selectedFrame} photos={capturedPhotos} onRetry={handleRetry} isSharedView={isSharedView} />;
            default:
              return <FrameSelector onFrameSelect={handleFrameSelect} />;
          }
        };

        return (
          <div className="min-h-screen flex flex-col font-sans text-gray-800">
            <Header />
            <main className="flex-grow flex items-center justify-center p-4 md:p-8">
              <div className="w-full max-w-4xl mx-auto">
                {renderContent()}
              </div>
            </main>
            <footer className="text-center p-4 text-brand-secondary">
              <p>&copy; 2024 Swayn. All rights reserved.</p>
            </footer>
          </div>
        );
      };

      // --- from index.tsx ---
      const rootElement = document.getElementById('root');
      if (!rootElement) {
        throw new Error("Could not find root element to mount to");
      }
      const root = ReactDOM.createRoot(rootElement);
      root.render(
        <React.StrictMode>
          <App />
        </React.StrictMode>
      );
    </script>
  </body>
</html>
